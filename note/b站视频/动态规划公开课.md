## 动态规划题目特点

1. 计数

* 有多少种方式做到右下角
* 有多少种方法选出 k 个数使得和是 sum

2. 求最大值最小值

* 从左上角走到右下角路径的最大数字和
* 最长上升子序列长度

3. 求存在性

* 取石子游戏，先手是否取胜
* 能不能选出 k 个数使得和是 sum

动态规划组成部分：

1. 确定状态

* 状态在动态规划中的作用属于定海神针
* 简单地说，接动态规划的时候需要开一个数组，数组的每个元素 f[i]或者 f[i][j]代表什么
  + 类似于解数学题中，x，y，z 代表什么
* 确定状态需要两个意识
  + 最后一步
  + 子问题

2. 转移方程

* 设状态 f[x] = 最少用多少枚硬币拼出 x
* 对于任意 x
  eg: f[X] = min{f[x-2] + 1, f[x-5] + 1, f[x-7] + 1}

3. 初始条件和边界情况

* 对于 f[X] = min{f[x-2] + 1, f[x-5] + 1, f[x-7] + 1}
* 两个问题：x-2， x-5 或者 x-7 小于 0 怎么办？ 什么时候停下来？
* 如果不能拼出 Y，就定义 f[y] = 正无穷
* 初始条件 f[0] = 0

4. 计算顺序

* 初始条件： f[0] = 0
* 然后计算 f[1], f[2], f[3]....f[27]
* 当我们计算到 f[X]时，f[x-2], f[x-5], f[x-7]都已经得到结果了。

例题：给定不同面值的硬币数组，和需要支付的金额，使用最少数量的硬币凑齐需要支付的金额。如果无法组成，则返回-1

```js
coinChange(coins, pay) {
    let f = [];
    f[0] = 0;
    for (let money = 1; money <= pay; ++money) {
        f[money] = Number.MAX_VALUE;
        for (let j = 0; j < coins.length; ++j) {
            if (money >= coins[j] && f[money - coins[j]] !== Number.MAX_VALUE) {
                f[money] = Math.min(f[money - coins[j]] + 1, f[money])
            }
        }
    }
    if (f[pay] === Number.MAX_VALUE) {
        f[pay] = -1
    }
    return f[pay];
}
```
